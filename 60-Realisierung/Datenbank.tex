\section{Datenbank}

Die Realisierung des Datenbank-Schemas wird über Migrationen in der Komponente des Game Information Systems durchgeführt. Sie wird jedoch aus Verständnisgründen in diesem Kapitel erläutert.

Die im Entwurf (\autoref{sec:Entwurf-Datenbank}) vorgestellten Tabellen wurden ohne Anpassungen realisiert. Da die Punkteberechnung nicht im Game Information System, durchgeführt werden soll, werden Views in der Datenbank genutzt, welche die benötigten Daten aus den verschieden Tabellen zusammensetzen.

Eine SQL-Datei zur Erstellung des Datenbank-Schemas befindet sich im mit abgebenden Quelltext der Bachelorarbeit, wurde aber aus Platzgründen weder hier noch im Anhang aufgenommen.

\subsection{Punkteübersicht}
Die Folgenden Views wurden in der Datenbank erstellt, um die Punkteberechnung zu ermöglichen. Sie wurde kleinschrittig gehalten und eine Nachvollziehbarkeit zu gewährleisten.

\subsubsection{Angriffspunkte}\label{subsubsec:Angriffspunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-offence}
	\captionof{figure}{View Angriffspunkte (ER-Diagramm)}
	\label{fig:realisierung-view-offence}
\end{center}

Wie in \autoref{label} erkennbar werden die Angriffspunkte (\textit{offence\_points}) über die Tabellen \textit{flags} und \textit{flags\_submitted} berechnet. Dafür wird für jede Gruppe, die Flags abgegeben hat, alle ihrer abgegebenen Flags mit allen vorhanden Flags gejoint, bei denen die besitzende Gruppe ungleich der abgebenden Gruppe ist. Die Anzahl der übergeblieben Flags wird gezählt und als Offensivpunkte ausgewiesen.

\begin{lstlisting}[frame=single, language=sql, caption={SQL View Angriffspunkte}, captionpos=b, label={lst:database-offence-points}]
SELECT flags_submitted.group_id, count(flags_submitted.flag_value) AS points
FROM (flags_submitted JOIN flags ON (((flags_submitted.flag_value)::text = (flags.flag_value)::text)))
WHERE (flags_submitted.group_id <> flags.group_id)
GROUP BY flags_submitted.group_id;
\end{lstlisting}

\subsubsection{Defensivpunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-defence}
	\captionof{figure}{View Defensivpunkte (ER-Diagramm)}
	\label{fig:realisierung-view-defence}
\end{center}

Ähnlich den Angriffspunkten (\ref{subsubsec:Angriffspunkte}) werden die Defensivpunkte (Strafe für verlorene Flags) berechnet.
Anders als bei den Angriffspunkten werden alle vorhanden Flags mit den abgegebenen Flags für jede Gruppe gejoint, wenn die besitzende Gruppe ungleich der abgebenden Gruppe ist. In dieser Liste können Flags mehrfach auftreten, wenn mehrere Gruppen einer Gruppe Flags geklaut haben. Da im alten System ein Verlust einer Flag an mehrere Gruppen nur einmal mit Minuspunkten bestraft worden ist, wird in der Liste der Flags mit der SQL Klausel \textit{DISTINCT} Duplikate entfernt. Im Anschluss werden dann die verlorenen Flags pro Gruppe gezählt und so die Defensivpunkte bestimmt.

\begin{lstlisting}[frame=single, language=sql, caption={SQL View Denfensivpunkte}, captionpos=b, label={lst:database-offence-points}]
SELECT flags.group_id, count(DISTINCT flags.flag_value) AS points
FROM (flags JOIN flags_submitted ON (((flags.flag_value)::text = (flags_submitted.flag_value)::text)))
WHERE (flags.group_id <> flags_submitted.group_id)
GROUP BY flags.group_id;
\end{lstlisting}

\subsubsection{Erkundungspunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-discover}
	\captionof{figure}{View Erkundungspunkte (ER-Diagramm)}
	\label{fig:realisierung-view-discover}
\end{center}

Die Erkundungspunkte werden nach dem gleichen Vorgehen wie die Angriffspunkte (\ref{subsubsec:Angriffspunkte}) bestimmt. Einziger Unterschied ist, dass nur Flags beachtet werden, bei denen die besitzende Gruppe gleicher der abgebenden Gruppe ist.

\begin{lstlisting}[frame=single, language=sql, caption={SQL View Erkundungspunkte}, captionpos=b, label={lst:database-offence-points}]
SELECT flags_submitted.group_id, count(flags_submitted.flag_value) AS points
FROM (flags_submitted JOIN flags ON (((flags_submitted.flag_value)::text = (flags.flag_value)::text)))
WHERE (flags_submitted.group_id = flags.group_id)
GROUP BY flags_submitted.group_id;
\end{lstlisting}

\subsubsection{Strafpunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-penalty}
	\captionof{figure}{View Strafpunkte (ER-Diagramm)}
	\label{fig:realisierung-view-penalty}
\end{center}

Die View der Strafpunkte (\textit{penalty\_points}) summiert die in der \textit{penalties}-Tabelle vorhanden Strafpunkte pro Gruppe auf. Andere Informationen wie Grund der Strafe bleiben hierfür unberücksichtigt. Jede Gruppe (\textit{group\_id}) hat entsprechende Strafpunkte (\textit{total\_penalty}). Sollte eine Gruppe bisher noch keine Strafpunkte erhalten haben, wird diese in der View nicht aufgeführt.

\subsubsection{Servicepunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-service-points}
	\captionof{figure}{View Servicepunkte (ER-Diagramm)}
	\label{fig:realisierung-view-service-points}
\end{center}

In der View \textit{group\_service\_points} werden pro Gruppe pro Service die Servicepunkte sowie die Serviceprozentzahl  berechnet. Dazu werden Daten aus den Tabellen \textit{services} und \textit{group\_service\_status} benötigt. Aus der Tabelle \textit{services} wird einzig die Gewichtung der einzelnen Services abgefragt. In der Tabelle \textit{group\_service\_status} werden die Anzahl der durchgeführten sowie der erfolgreichen Scans pro Gruppe abgerufen.

Die Servicepunkte werden zu Bewertung der Leistung der Absicherung und der Instandhaltung des Systems durch die Studierenden benötigt. Dazu wird das Ergebnis der Subtraktion gewichtet, um einen geringen Einfluss auf die Gesamtpunkte zu ermöglichen.

\begin{equation*}
	\frac{Anzahl~erfolgreicher~Scanvorgaenge - Anzahl~Scanvorgaenge}{Gewichtung}=~Strafpunkte
\end{equation*}


Die Serviceprozentzahl stellt für die Studierenden und betreuenden Personen die prozentuale Erreichbarkeit dar. Für die Berechnung dieser Prozentzahl pro Gruppe und Service wird die folgende Formel verwendet: 

\begin{equation*}
	\frac{100}{Anzahl~erfolgreicher~Scanvorgaenge}~*~Anzahl~Scanvorgaenge~=~Wert~in~\%
\end{equation*}

Um das Ergebnis einer Division durch 0 zu verhindern, wird im SQL Quelltext die Funktion \textit{COALESCE} verwendet. Diese nimmt den ersten Wert ungleich Null. Bei der Punkteberechnung kann durch eine Gewichtung gleich 0 die Division ein Ergebnis von Null zurückgeben sein. Deshalb wird dann die Gewichtung standardmäßig auf eins gesetzt. Wenn eine Gruppe keine erfolgreichen Scanvorgänge zu vermelden hat, wird das Ergebnis der Formel auf 0 gesetzt.

\begin{lstlisting}[frame=single, language=sql, caption={SQL Abfang von Division durch 0}, captionpos=b, label={lst:database-service-points-divison-by-0}]
COALESCE(NULLIF((services.weight)::integer, 0), 1)

COALESCE(((100 / group_service_status.scan_count) * group_service_status.online_count), 0)
\end{lstlisting}

\subsubsection{Flagshoppunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-flagshop}
	\captionof{figure}{View Flagshoppunkte (ER-Diagramm)}
	\label{fig:realisierung-view-flagshop}
\end{center}

Bei den Flagshoppunkten handelt es sich, um die für Käufe ausgegebenen Punkte einer Gruppe.
Für die Berechnung wird die Summe der Kosten aller gekauften Pakete pro Gruppe gebildet.
Wenn eine Gruppe keine Ausgaben getätigt hat, wird diese auch nicht in die View aufgenommen

\subsubsection{Challengepunkte}
\begin{center}
	\includegraphics[width=\linewidth]{realisierung/database/view-challenge}
	\captionof{figure}{View Challengepunkte (ER-Diagramm)}
	\label{fig:realisierung-view-challenge}
\end{center}

Im Gegensatz zum alten Überwachungs- und Auswertungssystems wird der Start einer Challenge nicht länger mit Minuspunkten bestraft. todo: Abschreckung für Studierende -> Versuchen Challenge nicht

Die Challengepunkte werden mithilfe der Tabellen \textit{challenges} und \textit{group\_has\_challenges} in der View \textit{challenge\_points} bestimmt. Für jede Gruppe werden die Punkte der gelösten Challenges summiert.

Sollten negativ Punkte für gestartete Challenges verteilt werden, muss der SQL Code der View angepasst werden, damit für jede gestartete Challenge Negativpunkte verrechnet werden. 

\subsubsection{Gesamtpunkte}
In der View \textit{total\_points} werden pro Gruppe alle vorher genannten Punkte inklusive einer Gesamtpunkteanzahl dargestellt. 

Die Gesamtpunkte setzen sich aus den genannten Punkten zusammen. Die Gesamtpunkte werden anhand der folgenden Formel berechnet.

\begin{multline*}
Challengepunkte + Erkundungspunkte + Offensivpunkte - Deffensivpunkte - \\ Servicepunkte - Flagshoppunkte - Strafpunkte = Gesamt~Punkte
\end{multline*}

Die Punkte werden aus den vorher dargestellten Views bezogen. Sollten Punkte nicht vorhanden sein, da beispielsweise eine Gruppe keine Challenges gelöst hat, werden diese Punkte durch die Nutzung von \textit{COALESCE} auf 0 gesetzt.

\begin{lstlisting}[frame=single, language=sql, caption={SQL Ersetzen nicht vorhandener Daten}, captionpos=b, label={lst:database-total-points-0}]
COALESCE(challenge.points, ((0)::smallint)) 
\end{lstlisting}

\subsection{Servicestatus}

Der aktuelle Servicestatus wird auch innerhalb einer View (\textit{group\_service\_online\_status}) ermöglicht. Diese View blendet nur Informationen der Tabelle \textit{group\_service\_status} aus, deshalb hätte auch die Tabelle selber genutzt werden können.

Die View stellt pro Gruppe und pro Service die Informationen zur Verfügung, ob der Scan im letzten Versuch erfolgreich war.