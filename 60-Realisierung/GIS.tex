\section{Game Information System}
Das Game Information System wurde als Rest-Schnittstelle implementiert. Sie kann über einen Rest-Client wie cURL, Insomnia oder einen eigenen Webclient angesprochen werden. Für die Realisierung wurde aufgrund der in \autoref{sec:Backend} angeführten Argumenten Flask als Framework gewählt.

Zuerst wird die Flask Anwendung mithilfe der Konfigurationsdatei eingestellt. Danach werden alle verwendeten Erweiterung mit der Flask Anwendung vertraut gemacht. Im folgenden werden die Befehle des Command-line Interfaces angelegt. Zum Schluss werden die Routen registriert und nicht vorhandene Einstellung mit Standardwerten in die \textit{settings}-Tabelle der Datenbank geschrieben.

In der Produktionsumgebung wird zur Betreibung der Web Server Gateway Interface(WSGI) HTTP Server \textit{gunicorn} verwendet, da der von Flask mitgebrachte WSGI Server nur für Entwicklungszwecke genutzt werden soll. Ein WSGI Server wird benötigt, um Anfragen an eine in Python geschriebene Webanwendung weiterzuleiten.

\subsection{Konfiguration}
Damit das CTF-Spiel durch die betreuenden Personen angepasst werden kann, gibt es neben einer Konfigurationsdatei auch Einstellungen, die in der Datenbank gespeichert werden.

In der Konfigurationsdatei werden die Informationen gespeichert, die selten oder niemals geändert werden müssen. Die in der Datenbank gespeicherten Einstellungen können durch die betreuenden Personen über das REST-Interface geändert werden.

\subsubsection{Konfigurationsdatei}
In der Konfigurationsdatei sind mehrheitlich Einstellungen für die Flask Anwendung sowie die Erweiterungen definiert. Dazu zählen \textit{secret keys} aber auch die Verbindungsdaten zur PostgreSQL- und Redis-Datenbank. Die secret keys werden genutzt um die gesendeten Informationen beispielsweise JWTs zu signieren und bei einer Antwort zu validieren.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Auszug aus der Konfiguration}, captionpos=b, label={lst:gis-config}]
FLAG_SECRET = "same_on_client"
FLAGSHOP_FLAG_SECRET = "another_secret"
SECRET_KEY = 'secret_key'
BEHIND_PROXY = True
PROXY_SECURE_VALUE = "http_header_pw"
JWT_SCRET_KEY = 'jwt_secret_key'
JWT_ACCESS_TOKEN_EXPIRES = datetime.timedelta(minutes=15)
JWT_REFRESH_TOKEN_EXPIRES = datetime.timedelta(hours=8)
REDIS_URL = "redis://localhost:6379"
SQLALCHEMY_DATABASE_URI = "postgresql://postgres:password@localhost:5432/postgres"
\end{lstlisting}

\subsubsection{Einstellungen} \label{subsub:realisierung-settings}
Über die Einstellungen lässt sich das Spiel leicht durch die betreuenden Personen verändern.
Dazu gehört beispielsweise, ob der Login für die Studierenden mit validen Hackit-Zugangsdaten geschehen muss oder ob ein sogenannter anonymer Login erlaubt ist. Aber auch kann eingestellt werden, ob das Spiel am Ende der Angriffszeit automatisch beendet und aufgeräumt werden soll. 

Nach dem ein Spiel beendet worden ist, ist es den Studierenden, anders als im derzeitig genutzten System, nicht mehr möglich weitere Aktionen durchzuführen. Für den Fall, dass dies nicht gewünscht ist, kann über die Einstellung das automatische beenden deaktiviert werden.

Ist die Einstellung gesetzt, dass das Spiel automatisch aufgeräumt werden soll, werden alle Tabellen kurz nach der Beendigung zurück gesetzt. Tabellen in denen Informationen hinterlegen, die über mehrere Spiele verwendet werden, bleiben unberührt.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Auszug aus den Einstellungen}, captionpos=b, label={lst:gis-settings}]
setting.require_hackit: true
setting.end_game_automatically: true
setting.backup_game_automatically: true
setting.cleanup_game_automatically: true
setting.flag_submitting_penalty_points: 10
setting.flags_per_group: app.config['FLAG_COUNT']
game.discover: 0
game.attack: 0
\end{lstlisting}

\subsection{Object-Relational Mapping}
Mit dem Object-Relational Mapping (ORM) können Daten aus der Datenbank mithilfe eines objektorientierten Paradigmas abgefragt oder manipuliert werden. Hierbei wird eine Verbindung zwischen einem Objekt in Python und einer Relation in der Datenbank geschaffen.

Über die Manipulation des Objekts lassen sich Änderungen am Datenbestand in der Datenbank durchführen. 

Für das ORM wird das Python-Toolkit \textit{SQLAlchemy} verwendet und durch die Flask Erweiterung \textit{Flask-SQLAlchemy} für die Nutzung innerhalb der Flask Anwendung konfiguriert. 

Die Objekte werden von der durch SQLAlchemy bereitgestellten Klasse \textit{Model} abgeleitet. Begründung fehlt
Für jede zu erzeugende Spalte in der Datenbank wird im ORM-Modell ein Attribut vom Typ \textit{Column}-Objekt erstellt. Das \textit{Column}-Objekt wird ebenfalls von \textit{SQLAlchemy} zur Verfügung gestellt und erhält Informationen wie den Datentyp und Constraints (primary key / foreign key).
Das Vorgehen wird exemplarisch in \autoref{lst:gis-orm-model} dargestellt.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Beispiel eines ORM Models}, captionpos=b, label={lst:gis-orm-model}]
class Backup(db.Model):
  __tablename__ = 'backups'
  
  id = db.Column(db.Integer, primary_key=True, autoincrement=True)
  created_at = db.Column(db.DateTime(timezone=True), server_default=func.now(), nullable=False)
  data = db.Column(db.JSON, nullable=False)
\end{lstlisting}

Auch implementieren die ORM-Modelle eine Klassenmethode über die Objekte anhand von bestimmten Informationen aus der Datenbank abgerufen werden können. Alternativ könnte anstatt der Verwendung der \textit{get}-Methode auch die \textit{query}-Methode aus der Basis-Klasse \textit{Model} verwendet werden. Dies wurde aus Konsistenzgründen und der häufigen nutzen im Quellcode nicht verwendet.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Beispiel einer Get-Methode des ORM Models}, captionpos=b, label={lst:gis-orm-model}]
class Backup(db.Model):
@classmethod
def get(cls, id: int = None, select_all: bool = False):
  if id is not None:
    return cls.query.get(id)
  elif select_all:
    return cls.query.all()
  else:
    return None
\end{lstlisting}

\subsubsection{Hash des Nutzer Passwortes}
Das Nutzermodell speichert das Passwort im privaten Attribute \textit{\_password}. In der Datenbank ist das Passwort aber in der Spalte \textit{password} abgelegt. Über die \textit{setter}-Methode kann das Passwort im Programmcode manipuliert werden.

Durch die Nutzung von \textit{getter}- und \textit{setter}-Methoden wird sichergestellt, dass alle Passwörter auf die gleiche Art und Weise gehasht werden und niemals im Klartext vorliegen.

Für das Passworthashing wird der Algorithmus \textit{bcrypt} verwendet, da dieser sequentiell abgearbeitet wird und daher langsamer als beispielsweise  \textit{sha} berechnet werden kann. Für die Erstellung eines Hashwertes wird zwingend, was aus IT-Sicherheitssicht eine gute Eigenschaft ist, ein Salt benötigt. Außerdem ist \textit{bcrypt} zukunftssicher, da der Algorithmus durch die verwendeten Rounds langsamer gemacht werden kann. Je mehr Rounds verwendet werden, desto länger dauert die Erzeugung eines Passwort-Hash. Diese Eigenschaften sollen Brute-Force-Angriff verlangsamen beziehungsweise teurer machen.

Die verwendeten Rounds bei der Erstellung des bcrypt-Passworthash mussten von 15 auf 10 gesetzt werden, da andernfalls ein Import der Hackit-Zugangsdaten mindestens 5 Minuten gedauert hätte.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Nutzerpasswort}, captionpos=b, label={lst:gis-orm-model}]
class User(db.Model):
...
_password = db.Column('password', db.String, nullable=False)
...
def get_password(self) -> str:
return self._password

def set_password(self, password):
custom_bcrypt = bcrypt.using(rounds=10)
self._password = custom_bcrypt.hash(password)

password = db.synonym('_password', descriptor=property(get_password, set_password))

def check_password(self, password: str) -> bool:
return bcrypt.verify(password, self.password)
\end{lstlisting}

\subsubsection{Flaggenerierung}
Für die Flaggenerierung muss derselbe Algorithmus und seed wie auf dem GameClient verwendet werden, damit dieselben Flags auf dem Server und dem Client generiert werden. Dazu wird ein seed (näheres zum seed ist in der Flaggenerierung in \autoref{sub:realisierung-gis-routen} beschrieben) mithilfe des Hash-Algorithmus \textit{md5} gehasht. Damit alle Flags als md5-Hash in der Datenbank abgelegt werden, wird auch hier eine \textit{getter}- und eine \textit{setter}-Methoden sowie ein privates Attribut genutzt. Die \textit{setter}-Methode erzeugt einen md5-Hash und speichert diesen im privaten Attribute. Sollte die Hashfunktion geändert werden, kann diese wie im Kommentar in \autoref{lst:gis-orm-model} erkennbar geändert werden.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Nutzerpasswort}, captionpos=b, label={lst:gis-orm-model}]
class Flag(db.Model):
  ...
  _value = db.Column('flag_value', db.String, primary_key=True)
  ...
  def get_value(self) -> str:
    return self._value

  def set_value(self, value: str) -> None:
    # self._value = sha512(value.encode('utf-8')).hexdigest()
    self._value = md5(value.encode('utf-8')).hexdigest()

  value = property(get_value, set_value)
\end{lstlisting}

\subsection{Migrationen}\label{sub:realisierung-migration}

Die Datenbank Migrationen werden aus den vorhanden ORM Modellen automatisch mit dem Datenbank-Migrationswerkzeug \textit{Alembic} und der Erweiterung \textit{Flask-Migrate} erzeugt. Einzig für die in \autoref{sec:Realisierung-Datenbank} eingeführten Views mussten manuell eigene Migrationsskripts angelegt werden.

Ein solches Skript kann nach Änderungen an einem oder mehreren ORM Models durch den in \ref{lst:gis-create-migration} gezeigten Befehl erzeugt werden.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Erzeugung eines Migrationsskripts}, captionpos=b, label={lst:gis-create-migration}]
flask db migrate
\end{lstlisting}

Mit den Skripts ist es möglich, die Datenbank auf ältere Iterationen zurückzusetzen, da bei Erstellung eines Iterationsschrittes auch der Weg zurück festgehalten wird.

Um die vorliegenden Migrationsskripts auf die Datenbank anzuwenden, werden die in \autoref{lst:gis-use-migration} gezeigten Befehle genutzt.

\begin{lstlisting}[language=bash, frame=single, caption={GIS Nutzung eines Migrationsskripts}, captionpos=b, label={lst:gis-use-migration}]
flask db upgrade
flask db downgrade <Version>
\end{lstlisting}

Die realisierten Tabellen und Views wurden in \autoref{sec:Realisierung-Datenbank} erläutert und werden deshalb hier nicht weiter aufgegriffen.

\subsection{Authentifizierung}\label{sub:realisierung-authentifizierung}

Für die Authentifizierung werden wie im Entwurf angedacht Tokens, spezieller JSON Web Tokens, verwendet. Es werden ein Access- und ein Refresh-Token nach einem erfolgreichen Login für die Nutzer erzeugt. Diese Tokens werden in der Redis-Datenbank für die Dauer ihrer Gültigkeit abgespeichert, um sie bei Bedarf ungültig zu machen. Bei der Authentifizierung wird zuerst geprüft, ob der vom Client gesendete Token als gültig in der Redis-Datenbank hinterlegt ist. Danach wird geprüft, ob der Token innerhalb seiner Lebensspanne verwendet wird.

Der Refresh-Token hat eine Gültigkeit von 8 Stunden und kann verwendet werden, um weitere Access-Tokens ohne Angabe der Nutzerdaten zu erstellen. Die Lebensdauer des Refresh-Tokens wurde auf 8 Stunden gesetzt, da es vorkommen kann, dass der Versuch zweimal hintereinander durch geführt wird. Das betreuende Personal muss sich dann nicht erneut anmelden.

Der Access-Token besitzt eine Gültigkeit von 15 Minuten und wird zur Authentifizierung und Autorisierung verwendet. Die Gültigkeit ist auf 15 Minuten begrenzt, da bei einem Verlust des Tokens an einen Angreifer maximal 15 Minuten Schaden angerichtet werden kann. Um Anfragen an die SQL-Datenbank zu minimieren werden Informationen, wie Rolle oder Gruppenzugehörigkeit, eines Nutzers mit in den Access-Token übernommen. Änderungen an den Berechtigung eines Nutzers werden so aber erst nach einem erneuten Ausstellen des Access-Tokens gültig.

\subsubsection{Decorator für Routen}
Um die Routen mit Berechtigungen zu versehen und redundanten Code zu verhindern wird bei der Absicherung auf Decorator zurückgegriffen. Sollte eine Route mit einem Decorator abgesichert werden, wird vor dem Aufruf der implementierten Funktion geprüft, ob der JWT die benötigten Berechtigungen besitzt.

In \autoref{table:gis-permission} sind die Routen mit ihren benötigten Berechtigungen dargestellt.

Es werden zwei Decorator zur Verfügung gestellt, beide prüfen, ob der Token im Feld \textit{role} die benötigte Rolle gesetzt hat. Der Unterschied zwischen \textit{role\_required} und \textit{roles\_required} ist, dass bei \textit{roles\_required} eine Liste von erlaubten Rollen angegeben werden kann. Dies wird auch im Code deutlich, da anstatt eines Variablen Vergleiches geprüft wird, ob die Rolle, die im JWT codiert ist, in der Liste der erlaubten Rollen vorhanden ist.

\begin{lstlisting}[language=Python, frame=single, caption={GIS Berechtigungsprüfung}, captionpos=b, label={lst:gis-permission-wrapper}]
def roles_required(roles: list):
  def _roles_required(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
    ...
    if get_jwt_claims()['role'] not in roles:
      raise Forbidden(f"You don't have any role of {roles}")
    else:
      return fn(*args, **kwargs)
  return wrapper
return _roles_required
\end{lstlisting}

Der Decorator \textit{flagshop\_route} wird für die Routen verwendet, welche einen gültigen Flagshop-Nutzer benötigen. Er nutzt den Implementierten \textit{role\_required} Decorator mit der Flagshop-Nutzer Rolle.

\subsection{Routen} \label{sub:realisierung-gis-routen}
Im Folgenden werden die implementierten Routen aufgegriffen. Eine Übersicht mit den implementierten Routen und den dazugehörigen Methoden befindet sich im Anhang in \autoref{table:gis-routes}

todo: Flask-RESTful erwähnen 

Wie bereits im Entwurf erwähnt erhalten alle Routen für die Versionierung den Präfix \textit{/v1}.

\subsubsection{Index}
Der Endpoint \textit{/} stellt über die \textit{GET}-Methode Hello-World im JSON-Format bereit. Dies kann beispielsweise genutzt werden, um zu testen, ob die Anwendung erreichbar ist. Denkbar aber nicht implementiert ist eine Liste der verfügbaren Endpoints und deren Methoden.

Um die Gültigkeit von Access-Tokens zu prüfen kann der Endpoint \textit{/secure} mit der \textit{GET}-Methode aufgerufen werden. Sollte der Token valide sein wird eine kurze Erfolgsnachricht, andernfalls eine Fehlernachricht, zurück gegeben.

\subsubsection{Login}
Für die Authentifizierung werden mehrere Endpoints benötigt.

Über den Endpoint \textit{/auth/login} werden mit einer validen Kombination aus Nutzernamen und Passwort der Access- und der Refresh-Token ausgestellt. Dazu müssen die Nutzerdaten mit der \textit{POST}-Methode an den Server übermittelt werden. Die Tokens werden dann im JSON-Format zurück gesendet.

\begin{lstlisting}[frame=single, caption={GIS Access- und Refresh-Token}, captionpos=b, label={lst:gis-login-tokens}]
{
  'access_token': base64-Access-Token,
  'refresh_token': base64-Refresh-Token
}

\end{lstlisting}

Die Gültigkeit kann wie bereits in \autoref{sub:realisierung-authentifizierung} erwähnt in der Konfiguration geändert werden und ist derzeitig auf 8 Stunden für den Refresh- und auf 15 Minuten für den Access-Token begrenzt.

Über den Endpoint \textit{/auth/refresh} kann ein valider Refresh-Token genutzt werden um ohne Angabe der Nutzerdaten einen neuen Access-Token zu erhalten.

Da die Access- und Refresh-Tokens anderes validiert werden, muss für das Zurückrufen der Tokens zwei Endpoints zur Verfügung stehen. Access-Tokens können an den Endpoint \textit{/auth/revoke/access} und Refresh-Tokens an den Endpoint \textit{/auth/revoke/refresh} gesendet werden. Sollten die angekommenen Tokens gültig sein, werden sie dann in der Redis-Datenbank als Zurückgerufen markiert.

Da der Access-Token für den Flagshop anders als der normale Access-Token aufgebaut ist, wird der Enpoint \textit{/auth/flagshop} benötigt. Dieser ist nur mit einem gültigen \textquote{normalen} Access-Token nutzbar. Für den Flagshop wird nur ein Access-Token mit einer Gültigkeit von 15 Minuten ausgestellt.

Ein Login ist für eine spielende Person nur dann möglich, wenn die eigene IP-Adresse in der Liste der GameClients oder deren Mitglieder vorhanden ist. Andernfalls scheitert der Login-In mit einer entsprechenden Fehlermeldung. Dies ist notwendig, damit das System bestimmen kann, für welche Gruppe eine Aktion ausgeführt worden ist.

\subsubsection{Nutzer}
Für die Verwaltung der Nutzer werden zwei Endpoints bereitgestellt. 

Der Endpoint (\textit{/user}) stellt über die Methode \textit{GET} für die betreuenden und administrierenden Personen eine Liste der im System vorliegen Log-In-Informationen bereit. Über die Methode \textit{POST} können besagte Personen neue Accounts anlegen. Accounts mit den Rollen \textit{supervisor} und \textit{admin} können nur durch administrierende Personen angelegt werden. Sollten alle Accounts mit der Rolle \textit{player} gelöscht werden, kann die Methode POST genutzt werden. Theoretisch könnte mit dieser Methode auch Accounts anderer Rollen gelöscht werden, dieses wurde limitiert, um ein unabsichtliches Löschen der Accounts des Hochschulpersonals zu verhindern.

\begin{lstlisting}[language=Python, frame=single, caption={GIS Löschen auf player-Accounts begrenzen}, captionpos=b, label={lst:gis-delete-all-players}]
if args['role'] != 'player':
  raise Conflict('Currently only mass deletions of players are supported.')
\end{lstlisting}

Die Funktion wurde geschaffen, um die Hackit-Zugangsdaten nach Ende des Semesters aus der Datenbank zu entfernen.

Über die Methoden \textit{GET}, \textit{PUT} und \textit{DELETE} des Endpoints \textit{/user/<int:user\_id>} wird eine Verwaltung einzelner Accounts ermöglicht. Hierzu muss bei der Anfrage die Account-ID übergeben werden. Die Methode \textit{GET} zeigt alle Informationen zu dem bestimmten Account an. Über die Methode \textit{PUT} können einzelne Informationen verändert und über die Methode \textit{DELETE} kann der Account gelöscht werden.

Die betreuende Personen dürfen auch hier nur Accounts der Rolle \textit{player} sowie ihre eigenen verwalten. Die eigenen Rolle kann nur auf die Rolle \textit{player} geändert werden. Dies soll unerlaubte Rechteausweitung verhinder. Des Weiteren ist es nicht möglich den aktuellen Account zu löschen. Sollte dieses benötigt werden, muss dafür ein weitere Account genutzt werden.

Außerdem ist ein dritter Endpoint, erreichbar unter \textit{/user/import}, implementiert, der das Importieren von Hackit-Zugangsdaten ermöglicht. Hierfür wird eine Datei per HTTP-Request \textit{POST} an den Server gesendet. Die Login-In-Informationen werden zeilenweise ausgelesen und mit der Rolle \textit{Player} angelegt. Ein Import von beispielsweise Administratoren kann auf ähnliche Art realisiert werden, wurde jedoch nicht implementiert, da dieses zum jetzigen Zeitpunkt nicht benötigt wird.

\subsubsection{GameClient}

GameClientList
-> Liste der teilnehmenden Gruppen, anlegen neuer Gruppen
 -> Flag generierung
 
GameClient
-> Anzeigen inkl. Gruppen Mitglieder
Löschen

\subsubsection{Gruppen Mitglieder}
AssociateList
-> Erstellen von Gruppen Mitgliedern
-> Anzeigen aller Gruppen Mitgliedern

Associate
-> Löschen von Gruppen Mitgliedern

\subsubsection{Einstellungen}
Über den Endpoint \textit{/setting} ist es den betreuenden und administrierenden Personen möglich, die im Spiel genutzten Einstellungen zu ändern. Dazu können alle Einstellungen (siehe \autoref{subsub:realisierung-settings}) über die \textit{GET}-Methode angefragt und mithilfe der \textit{PUT}-Methode verändert werden.

\subsubsection{Flag}
Über den Endpoint \textit{/flag} können die Studierenden die gefundenen und erhaltenden Flags abgeben. Für die Punkteverrechnung wird die im Access-Token codierte Gruppe benötigt. Eine Abgabe von Flags wird verhindert, falls das Spiel nicht aktiv ist (noch nicht gestartet, beendet oder pausiert).

Die Validierung der Flag wird mithilfe der \textit{flags}-Tabelle durchgeführt, indem geprüft wird ob die abgegebene Flag vorhanden ist.

Im Anschluss wird geprüft, ob es sich bei der abgegebenen Flag um eine Flag handelt, die nicht auf den GameClients verteilt ist und durch eine andere Gruppe als der Besitzenden abgegeben wird. Dieses wird nur geprüft, wenn die abgebende und gleich der besitzenden Gruppe ist und verhindert die Abgabe von bspw. Flagshop-Flags durch andere Gruppen. 

\begin{lstlisting}[language=Python, frame=single, caption={GIS Abgabe privater Flags verhindern}, captionpos=b, label={lst:gis-prevent-submitting-private-flags}]
if flag.group_id != group_id and flag.usage != "on_client":
  raise BadRequest("Private flags cannot be submitted")
\end{lstlisting}

Sollten fremde Flags während der Discover-Zeit abgegeben werden, bestraft das System die abgebende Gruppe für ihr regelverletzendes Verhalten automatisch. Die Flag muss von der Gruppe nach Start der Attack-Time erneut abgegeben werden, um Punkte für diese zu erhalten.

\begin{lstlisting}[language=Python, frame=single, caption={GIS Strafe für abgeben fremder Flags}, captionpos=b, label={lst:gis-delete-all-players}]
if game_status_setting.value == "discover" and flag.group_id != group_id:
  penalty = Penalty(reason="Submitted an alien flag during discovery", points=penalty_points,
  group_id=group.id)
  raise Conflict("You submitted an alien flag during discovery. The flag is not accepted. You'll be punished.")
\end{lstlisting}

Sollten alle Überprüfungen ohne Probleme durchlaufen sein, wird die Flag inklusive der abgebenden Gruppe in der \textit{flags\_submitted}-Tabelle abgespeichert. Die Berechnung der Punkte erfolgt wie in \autoref{sec:Realisierung-Datenbank} beschrieben über die Views.

Der Endpoint ist mit einem Rate Limiter versehen, welcher eine Brute-Force Abgabe von Flags verhindern soll. Pro Gruppe werden in der Minute nicht mehr als 60 Flags akzeptiert. Dieser Wert kann nach Bedarf verändert werden.

\subsubsection{Spielsteuerung}

Flask APScheduler erwähnen -> automatisches beenden etc.

\subsubsection{Scanner-Steuerung}
Verwalten des Scanners mithilfe von Docker -> Name des Containers in der Einstellung gespeichert, Status des Scanners auch in Einstellungen

\subsubsection{Spielstände}
Der aktuellen Spielstand kann über den Endpoint \textit{/match/score} abgerufen werden. Dazu werden die Informationen aus der Datenbank aufbereitet. Neben den Gruppenpunkten aus der \textit{total\_points}-View werden auch die aktiven Services inklusive ihrer respektiven Namen sowie die Überschriften für die Punktetabelle übermittelt.

Über den Endpoint \textit{/match/info} können die aktuellen Spielinformationen abgerufen werden. Zu den Spielinformationen zählt der aktuelle Status des Spiels und des Scanners sowie der Endzeitpunkt der Discover- und Attack-Zeit.

Alte Spielstände können über die Endpoints \textit{/backup} und \textit{/backup/<int:backup\_id>} abgerufen werden.
Der Endpoint \textit{/backup} gibt nur eine Liste der vorhanden Spielstände inklusive des Zeitpunkt der Speicherung zurück. Mithilfe der Liste kann eine Spielstand ID ausgesucht werden und der Spielstand über den Endpoint \textit{/backup/<int:backup\_id>} abgerufen werden.

Bei alten Spielstände werden die Daten im JSON-Format in der Variable \textit{data} abgelegt.

\subsubsection{Strafe}
Über den Endpoint \textit{/penalty} können alle ausgesprochenden Strafen über die \textit{GET}-Methode angesehen werden. Administrierende und betreuende Personen können über die \textit{POST}-Methode neue Strafen erstellen. Hierzu sind Angaben zu Grund, Anzahl der Strafpunkte sowie die zu bestrafende Gruppe notwendig.

Der Endpoint \textit{/penalty/<int:penalty\_id>} kann von den administrierende und betreuende Personen genutzt werden um einzelne Strafen anzusehen (\textit{GET}), zu bearbeiten (\textit{PUT}) und zu löschen (\textit{DELETE}).

\subsubsection{Flagshop}

Nutzer
Pakete
Kaufe

\subsubsection{Challenge}

Liste der Challenges
Challenges
Abgabe von Challenges

\subsubsection{Notizen}
Über die \textit{POST}-Methode des Endpoints \textit{/note} sind administrierende oder betreuende Personen in der Lage neue Notizen zu erstellen. Notizen können über den Endpoint \textit{/note/<int:note\_id>} verändert (\textit{PUT}) oder gelöscht (\textit{DELETE}) werden.

Die hinterlegten Notizen können als Liste über die \textit{/v1/note}-Methode des Endpoints \textit{/note/<int:note\_id>} oder einzeln über die \textit{GET}-Methode des Endpoints \textit{text} abgerufen werden

\subsubsection{Log}
Um die Aktionen des Scanners nachvollziehen zu können, werden Log-Einträge abgespeichert. Diese können durch betreuende und administrierende Personen über den Endpoint \textit{/log} eingesehen werden. Außerdem ist es diesen Personen möglich, eigene Log-Einträge mithilfe der \textit{POST}-Methode zu erstellen.

Log Informationen des letzten Spiels können über den Endpoint \textit{/log/old} abgerufen werden.
	
\subsection{CLI Befehle}
Die Erweiterungen \textit{Flask-Migrate} und \textit{Flask-RESTful} stellen CLI-Befehle zur Verfügung.

\textit{Flask-Migrate} stellt die in \autoref{sub:realisierung-migration} vorgestellten Befehle zur Verfügung. Über den Befehl \textit{flask routes} zeigt \textit{Flask-RESTful} alle registrierten Ressourcen mit den entsprechenden Methoden und Routen an.

Außerdem ermöglicht ein selbst programmierte Befehl es, ohne Angabe von Login-Informationen, Nutzer zu verwalten. Dies wird zum Einem benötigt, um den ersten Benutzer anzulegen. Auch kann so bei Verlust aller Adminkennungen eine bestehende Kennung geändert oder eine neue angelegt werden. Sollte bei einem Befehl nicht alle benötigten Informationen angegeben werden, erfragt die Anwendung diese über die Befehlszeile.

\begin{lstlisting}[language=bash, frame=single, caption={GIS CLI}, captionpos=b, label={lst:gis-cli}]
flask user create username --role admin/supervisor/player --password secure_pw
flask user delete username
flask user create username --role admin/supervisor/player --password secure_pw
\end{lstlisting}